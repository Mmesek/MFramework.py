window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "MFramework", "modulename": "MFramework", "type": "module", "doc": "<h6 id=\"mframework\">MFramework</h6>\n\n<p>Discord API framework with Database support.</p>\n\n<p>:copyright: (c) 2020-2021 Mmesek</p>\n"}, {"fullname": "MFramework.Priority", "modulename": "MFramework", "qualname": "Priority", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "mlib.types.Enum"}, {"fullname": "MFramework.Priority.Commands", "modulename": "MFramework", "qualname": "Priority.Commands", "type": "variable", "doc": "<p>High priority. Command Function, execute ASAP</p>\n", "default_value": " = <Priority.Commands: 5>"}, {"fullname": "MFramework.Priority.Filters", "modulename": "MFramework", "qualname": "Priority.Filters", "type": "variable", "doc": "<p>Content Filtering, payload might become invalid afterwards</p>\n", "default_value": " = <Priority.Filters: 10>"}, {"fullname": "MFramework.Priority.Parsers", "modulename": "MFramework", "qualname": "Priority.Parsers", "type": "variable", "doc": "<p>Parsing functions, there might be something in content</p>\n", "default_value": " = <Priority.Parsers: 50>"}, {"fullname": "MFramework.Priority.Default", "modulename": "MFramework", "qualname": "Priority.Default", "type": "variable", "doc": "<p>Medium priority, execution doesn't matter</p>\n", "default_value": " = <Priority.Default: 100>"}, {"fullname": "MFramework.Priority.Activity", "modulename": "MFramework", "qualname": "Priority.Activity", "type": "variable", "doc": "<p>Execute only if previous steps didn't stop iteration, rewards etc</p>\n", "default_value": " = <Priority.Activity: 150>"}, {"fullname": "MFramework.Priority.Logging", "modulename": "MFramework", "qualname": "Priority.Logging", "type": "variable", "doc": "<p>Low priority, execution doesn't matter if previous steps stopped</p>\n", "default_value": " = <Priority.Logging: 200>"}, {"fullname": "MFramework.Priority.Low", "modulename": "MFramework", "qualname": "Priority.Low", "type": "variable", "doc": "<p>Optional execution</p>\n", "default_value": " = <Priority.Low: 300>"}, {"fullname": "MFramework.Priority.High", "modulename": "MFramework", "qualname": "Priority.High", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Priority.Commands: 5>"}, {"fullname": "MFramework.Priority.Medium", "modulename": "MFramework", "qualname": "Priority.Medium", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Priority.Default: 100>"}, {"fullname": "MFramework.api", "modulename": "MFramework.api", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.api.spotify", "modulename": "MFramework.api.spotify", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.api.spotify.Spotify", "modulename": "MFramework.api.spotify", "qualname": "Spotify", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.api.spotify.Spotify.__init__", "modulename": "MFramework.api.spotify", "qualname": "Spotify.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, config={})", "funcdef": "def"}, {"fullname": "MFramework.api.spotify.Spotify.spotify_call", "modulename": "MFramework.api.spotify", "qualname": "Spotify.spotify_call", "type": "function", "doc": "<p></p>\n", "signature": "(self, path, querry, method='GET', **kwargs)", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.connect", "modulename": "MFramework.api.spotify", "qualname": "Spotify.connect", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.disconnect", "modulename": "MFramework.api.spotify", "qualname": "Spotify.disconnect", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.refresh", "modulename": "MFramework.api.spotify", "qualname": "Spotify.refresh", "type": "function", "doc": "<p></p>\n", "signature": "(self, refresh_token, force=False)", "funcdef": "def"}, {"fullname": "MFramework.api.spotify.Spotify.search", "modulename": "MFramework.api.spotify", "qualname": "Spotify.search", "type": "function", "doc": "<p></p>\n", "signature": "(self, query, type='artist', additional='')", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.searchNew", "modulename": "MFramework.api.spotify", "qualname": "Spotify.searchNew", "type": "function", "doc": "<p></p>\n", "signature": "(self, query, type='artist', additional='')", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.new", "modulename": "MFramework.api.spotify", "qualname": "Spotify.new", "type": "function", "doc": "<p></p>\n", "signature": "(self, market='gb')", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.observed", "modulename": "MFramework.api.spotify", "qualname": "Spotify.observed", "type": "function", "doc": "<p></p>\n", "signature": "(self, db, market='gb')", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.check", "modulename": "MFramework.api.spotify", "qualname": "Spotify.check", "type": "function", "doc": "<p></p>\n", "signature": "(self, chunk, one='Various')", "funcdef": "async def"}, {"fullname": "MFramework.api.spotify.Spotify.makeList", "modulename": "MFramework.api.spotify", "qualname": "Spotify.makeList", "type": "function", "doc": "<p></p>\n", "signature": "(self, db, market='gb')", "funcdef": "async def"}, {"fullname": "MFramework.api.steam", "modulename": "MFramework.api.steam", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.api.steam.URL", "modulename": "MFramework.api.steam", "qualname": "URL", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "MFramework.api.steam.URL.STEAM", "modulename": "MFramework.api.steam", "qualname": "URL.STEAM", "type": "variable", "doc": "<p></p>\n", "default_value": " = <URL.STEAM: 'http://api.steampowered.com/'>"}, {"fullname": "MFramework.api.steam.URL.STORE", "modulename": "MFramework.api.steam", "qualname": "URL.STORE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <URL.STORE: 'https://store.steampowered.com/api/'>"}, {"fullname": "MFramework.api.steam.Steam", "modulename": "MFramework.api.steam", "qualname": "Steam", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.api.steam.Steam.__init__", "modulename": "MFramework.api.steam", "qualname": "Steam.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, token)", "funcdef": "def"}, {"fullname": "MFramework.api.steam.Steam.api_call", "modulename": "MFramework.api.steam", "qualname": "Steam.api_call", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self=None,\n    path='',\n    querry='',\n    method='GET',\n    api=<URL.STEAM: 'http://api.steampowered.com/'>,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.resolveVanityUrl", "modulename": "MFramework.api.steam", "qualname": "Steam.resolveVanityUrl", "type": "function", "doc": "<p></p>\n", "signature": "(self, username)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.getPrices", "modulename": "MFramework.api.steam", "qualname": "Steam.getPrices", "type": "function", "doc": "<p></p>\n", "signature": "(self, steamids, currency)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.OwnedGames", "modulename": "MFramework.api.steam", "qualname": "Steam.OwnedGames", "type": "function", "doc": "<p></p>\n", "signature": "(self, steamid)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.PlayerSummaries", "modulename": "MFramework.api.steam", "qualname": "Steam.PlayerSummaries", "type": "function", "doc": "<p></p>\n", "signature": "(self, steamids)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.getAppList", "modulename": "MFramework.api.steam", "qualname": "Steam.getAppList", "type": "function", "doc": "<p></p>\n", "signature": "(self, language='english')", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.News", "modulename": "MFramework.api.steam", "qualname": "Steam.News", "type": "function", "doc": "<p></p>\n", "signature": "(self, appid)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.CurrentPlayers", "modulename": "MFramework.api.steam", "qualname": "Steam.CurrentPlayers", "type": "function", "doc": "<p></p>\n", "signature": "(appid)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.AppList", "modulename": "MFramework.api.steam", "qualname": "Steam.AppList", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.Featured", "modulename": "MFramework.api.steam", "qualname": "Steam.Featured", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.Steam.appDetails", "modulename": "MFramework.api.steam", "qualname": "Steam.appDetails", "type": "function", "doc": "<p></p>\n", "signature": "(appid, language)", "funcdef": "async def"}, {"fullname": "MFramework.api.steam.loadSteamIndex", "modulename": "MFramework.api.steam", "qualname": "loadSteamIndex", "type": "function", "doc": "<p></p>\n", "signature": "(ctx)", "funcdef": "async def"}, {"fullname": "MFramework.bot", "modulename": "MFramework.bot", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.bot.Bot", "modulename": "MFramework.bot", "qualname": "Bot", "type": "class", "doc": "<p>Event Listener mixin</p>\n", "bases": "mdiscord.websocket.WebSocket_Client"}, {"fullname": "MFramework.bot.Bot.__init__", "modulename": "MFramework.bot", "qualname": "Bot.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    cfg: dict,\n    db: MFramework.database.database.Database = None,\n    cache: MFramework.database.cache.Cache = None,\n    shard: int = 0,\n    total_shards: int = 1\n)", "funcdef": "def"}, {"fullname": "MFramework.bot.Bot.session_id", "modulename": "MFramework.bot", "qualname": "Bot.session_id", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = None"}, {"fullname": "MFramework.bot.Bot.start_time", "modulename": "MFramework.bot", "qualname": "Bot.start_time", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = None"}, {"fullname": "MFramework.bot.Bot.application", "modulename": "MFramework.bot", "qualname": "Bot.application", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Application", "default_value": " = None"}, {"fullname": "MFramework.bot.Bot.registered_commands", "modulename": "MFramework.bot", "qualname": "Bot.registered_commands", "type": "variable", "doc": "<p></p>\n", "default_value": " = None"}, {"fullname": "MFramework.bot.Bot.registered", "modulename": "MFramework.bot", "qualname": "Bot.registered", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "MFramework.bot.Bot.alias", "modulename": "MFramework.bot", "qualname": "Bot.alias", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = '?'"}, {"fullname": "MFramework.bot.Bot.emoji", "modulename": "MFramework.bot", "qualname": "Bot.emoji", "type": "class", "doc": "<p>dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)</p>\n"}, {"fullname": "MFramework.bot.Bot.primary_guild", "modulename": "MFramework.bot", "qualname": "Bot.primary_guild", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = 463433273620824104"}, {"fullname": "MFramework.bot.Bot.dispatch", "modulename": "MFramework.bot", "qualname": "Bot.dispatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data: mdiscord.models.Gateway_Payload)", "funcdef": "async def"}, {"fullname": "MFramework.bot.ready", "modulename": "MFramework.bot", "qualname": "ready", "type": "function", "doc": "<p></p>\n", "signature": "(self: MFramework.bot.Bot, ready: mdiscord.models.Ready)", "funcdef": "async def"}, {"fullname": "MFramework.commands", "modulename": "MFramework.commands", "type": "module", "doc": "<h6 id=\"commands\">Commands</h6>\n\n<p>Command registery &amp; execution framework</p>\n\n<p>:copyright: (c) 2021 Mmesek</p>\n"}, {"fullname": "MFramework.commands.commands", "modulename": "MFramework.commands.commands", "type": "module", "doc": "<h6 id=\"commands\">Commands</h6>\n\n<p>Message command execution framework</p>\n\n<p>:copyright: (c) 2020-2021 Mmesek</p>\n"}, {"fullname": "MFramework.commands.commands.check_command", "modulename": "MFramework.commands.commands", "qualname": "check_command", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    message: mdiscord.types.Message,\n    dm: bool = False\n) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.commands.check_direct_command", "modulename": "MFramework.commands.commands", "qualname": "check_direct_command", "type": "function", "doc": "<p></p>\n", "signature": "(client: MFramework.bot.Bot, message: mdiscord.types.Message) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.commands.check_regex", "modulename": "MFramework.commands.commands", "qualname": "check_regex", "type": "function", "doc": "<p></p>\n", "signature": "(client: MFramework.bot.Bot, message: mdiscord.types.Message) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.commands.check_shortcuts", "modulename": "MFramework.commands.commands", "qualname": "check_shortcuts", "type": "function", "doc": "<p></p>\n", "signature": "(client: MFramework.bot.Bot, message: mdiscord.types.Message) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.commands.check_reaction", "modulename": "MFramework.commands.commands", "qualname": "check_reaction", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    reaction: mdiscord.models.Message_Reaction_Add\n) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.components", "modulename": "MFramework.commands.components", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.components.run_function", "modulename": "MFramework.commands.components", "qualname": "run_function", "type": "function", "doc": "<p></p>\n", "signature": "(\n    cmd: MFramework.commands.components.MetaCommand,\n    ctx: MFramework.context.Context,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.MetaCommand", "modulename": "MFramework.commands.components", "qualname": "MetaCommand", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.components.MetaCommand.__init__", "modulename": "MFramework.commands.components", "qualname": "MetaCommand.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.commands.components.MetaCommand.auto_deferred", "modulename": "MFramework.commands.components", "qualname": "MetaCommand.auto_deferred", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "MFramework.commands.components.MetaCommand.private_response", "modulename": "MFramework.commands.components", "qualname": "MetaCommand.private_response", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "MFramework.commands.components.MetaCommand.execute", "modulename": "MFramework.commands.components", "qualname": "MetaCommand.execute", "type": "function", "doc": "<p></p>\n", "signature": "(\n    cls,\n    ctx: MFramework.context.Context,\n    data: str,\n    values: List[str] = None,\n    not_selected: List[mdiscord.models.Select_Option] = None\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.components", "modulename": "MFramework.commands.components", "qualname": "components", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, MFramework.commands.components.MetaCommand]", "default_value": " = {'Component': <class 'MFramework.commands.components.Component'>, 'Select': <class 'MFramework.commands.components.Select'>, 'Button': <class 'MFramework.commands.components.Button'>, 'LinkButton': <class 'MFramework.commands.components.LinkButton'>, 'Modal': <class 'MFramework.commands.components.Modal'>, 'TextInput': <class 'MFramework.commands.components.TextInput'>}"}, {"fullname": "MFramework.commands.components.interaction_create", "modulename": "MFramework.commands.components", "qualname": "interaction_create", "type": "function", "doc": "<p>Called after receiving event INTERACTION_CREATE from Discord\nReacts only to Components (Buttons)</p>\n", "signature": "(client: MFramework.bot.Bot, interaction: mdiscord.types.Interaction)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.Row", "modulename": "MFramework.commands.components", "qualname": "Row", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "mdiscord.models.Component"}, {"fullname": "MFramework.commands.components.Row.__init__", "modulename": "MFramework.commands.components", "qualname": "Row.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *components: mdiscord.models.Component)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Row.type", "modulename": "MFramework.commands.components", "qualname": "Row.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Component_Types", "default_value": " = 1"}, {"fullname": "MFramework.commands.components.Row.components", "modulename": "MFramework.commands.components", "qualname": "Row.components", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[mdiscord.models.Component]", "default_value": " = None"}, {"fullname": "MFramework.commands.components.ActionRow", "modulename": "MFramework.commands.components", "qualname": "ActionRow", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "mdiscord.models.Component"}, {"fullname": "MFramework.commands.components.ActionRow.__init__", "modulename": "MFramework.commands.components", "qualname": "ActionRow.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *components: mdiscord.models.Component)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.ActionRow.type", "modulename": "MFramework.commands.components", "qualname": "ActionRow.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Component_Types", "default_value": " = 1"}, {"fullname": "MFramework.commands.components.ActionRow.components", "modulename": "MFramework.commands.components", "qualname": "ActionRow.components", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[mdiscord.models.Component]", "default_value": " = None"}, {"fullname": "MFramework.commands.components.Component", "modulename": "MFramework.commands.components", "qualname": "Component", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "mdiscord.models.Component, MetaCommand"}, {"fullname": "MFramework.commands.components.Component.__init__", "modulename": "MFramework.commands.components", "qualname": "Component.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, custom_id: str = None)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Select", "modulename": "MFramework.commands.components", "qualname": "Select", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Component"}, {"fullname": "MFramework.commands.components.Select.__init__", "modulename": "MFramework.commands.components", "qualname": "Select.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    *options: mdiscord.models.Select_Option,\n    custom_id: str = None,\n    placeholder: str = None,\n    min_values: int = 0,\n    max_values: int = 1,\n    disabled: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Select.execute", "modulename": "MFramework.commands.components", "qualname": "Select.execute", "type": "function", "doc": "<p></p>\n", "signature": "(\n    cls,\n    ctx: MFramework.context.Context,\n    data: str,\n    values: List[str],\n    not_selected: List[mdiscord.models.Select_Option]\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.Option", "modulename": "MFramework.commands.components", "qualname": "Option", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>label:\n    the user-facing name of the option, max 25 characters\nvalue:\n    the dev-define value of the option, max 100 characters\ndescription:\n    an additional description of the option, max 50 characters\nemoji:\n    <code>id</code>, <code>name</code>, and <code>animated</code>\ndefault:\n    will render this option as selected by default</p>\n", "bases": "mdiscord.models.Select_Option"}, {"fullname": "MFramework.commands.components.Option.__init__", "modulename": "MFramework.commands.components", "qualname": "Option.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    label: str,\n    value: str,\n    description: str = None,\n    emoji: mdiscord.models.Emoji = None,\n    default: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.SelectMenu", "modulename": "MFramework.commands.components", "qualname": "SelectMenu", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Component"}, {"fullname": "MFramework.commands.components.SelectMenu.__init__", "modulename": "MFramework.commands.components", "qualname": "SelectMenu.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    *options: mdiscord.models.Select_Option,\n    custom_id: str = None,\n    placeholder: str = None,\n    min_values: int = 0,\n    max_values: int = 1,\n    disabled: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.SelectMenu.execute", "modulename": "MFramework.commands.components", "qualname": "SelectMenu.execute", "type": "function", "doc": "<p></p>\n", "signature": "(\n    cls,\n    ctx: MFramework.context.Context,\n    data: str,\n    values: List[str],\n    not_selected: List[mdiscord.models.Select_Option]\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.SelectOption", "modulename": "MFramework.commands.components", "qualname": "SelectOption", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>label:\n    the user-facing name of the option, max 25 characters\nvalue:\n    the dev-define value of the option, max 100 characters\ndescription:\n    an additional description of the option, max 50 characters\nemoji:\n    <code>id</code>, <code>name</code>, and <code>animated</code>\ndefault:\n    will render this option as selected by default</p>\n", "bases": "mdiscord.models.Select_Option"}, {"fullname": "MFramework.commands.components.SelectOption.__init__", "modulename": "MFramework.commands.components", "qualname": "SelectOption.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    label: str,\n    value: str,\n    description: str = None,\n    emoji: mdiscord.models.Emoji = None,\n    default: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Button", "modulename": "MFramework.commands.components", "qualname": "Button", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Component"}, {"fullname": "MFramework.commands.components.Button.__init__", "modulename": "MFramework.commands.components", "qualname": "Button.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    label: str,\n    custom_id: str = None,\n    style: mdiscord.models.Button_Styles = <Button_Styles.PRIMARY: 1>,\n    emoji: mdiscord.models.Emoji = None,\n    disabled: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Button.type", "modulename": "MFramework.commands.components", "qualname": "Button.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Component_Types", "default_value": " = <Component_Types.BUTTON: 2>"}, {"fullname": "MFramework.commands.components.Button.style", "modulename": "MFramework.commands.components", "qualname": "Button.style", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Button_Styles", "default_value": " = <Button_Styles.PRIMARY: 1>"}, {"fullname": "MFramework.commands.components.LinkButton", "modulename": "MFramework.commands.components", "qualname": "LinkButton", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Button"}, {"fullname": "MFramework.commands.components.LinkButton.__init__", "modulename": "MFramework.commands.components", "qualname": "LinkButton.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    label: str,\n    url: str = None,\n    emoji: mdiscord.models.Emoji = None,\n    disabled: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.LinkButton.style", "modulename": "MFramework.commands.components", "qualname": "LinkButton.style", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Button_Styles", "default_value": " = <Button_Styles.LINK: 5>"}, {"fullname": "MFramework.commands.components.Modal", "modulename": "MFramework.commands.components", "qualname": "Modal", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Component"}, {"fullname": "MFramework.commands.components.Modal.__init__", "modulename": "MFramework.commands.components", "qualname": "Modal.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    *components: MFramework.commands.components.Component,\n    title: str = None,\n    custom_id: str = None\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.Modal.type", "modulename": "MFramework.commands.components", "qualname": "Modal.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.models.Component_Types", "default_value": " = None"}, {"fullname": "MFramework.commands.components.Modal.disabled", "modulename": "MFramework.commands.components", "qualname": "Modal.disabled", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = None"}, {"fullname": "MFramework.commands.components.Modal.execute", "modulename": "MFramework.commands.components", "qualname": "Modal.execute", "type": "function", "doc": "<p></p>\n", "signature": "(\n    cls,\n    ctx: MFramework.context.Context,\n    data: str,\n    inputs: Dict[str, str]\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.components.TextInput", "modulename": "MFramework.commands.components", "qualname": "TextInput", "type": "class", "doc": "<h6 id=\"atrributes\">Atrributes</h6>\n\n<p>type:\n    Component_Type\nstyle:\n    Button_Styles\nlabel:\n    text that appears on the button, max 80 characters\nemoji:\n    <code>name</code>, <code>id</code>, and <code>animated</code>\ncustom_id:\n    a developer-defined identifier for the button, max 100 characters\nurl:\n    a url for link-style buttons\ndisabled:\n    whether the button is disabled, default <code>false</code>\ncomponents:\n    a list of child components</p>\n", "bases": "Component"}, {"fullname": "MFramework.commands.components.TextInput.__init__", "modulename": "MFramework.commands.components", "qualname": "TextInput.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    label: str,\n    custom_id: str = None,\n    style: mdiscord.models.Text_Input_Styles = <Text_Input_Styles.Paragraph: 2>,\n    min_length: int = 0,\n    max_length: int = 4000,\n    required: bool = False,\n    value: str = None,\n    placeholder: str = None\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.components.TextInput.type", "modulename": "MFramework.commands.components", "qualname": "TextInput.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 4"}, {"fullname": "MFramework.commands.components.Autocomplete", "modulename": "MFramework.commands.components", "qualname": "Autocomplete", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.components.Autocomplete.__init__", "modulename": "MFramework.commands.components", "qualname": "Autocomplete.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *choices)", "funcdef": "def"}, {"fullname": "MFramework.commands.context", "modulename": "MFramework.commands.context", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.context.check_context", "modulename": "MFramework.commands.context", "qualname": "check_context", "type": "function", "doc": "<p></p>\n", "signature": "(self, data) -> bool", "funcdef": "async def"}, {"fullname": "MFramework.commands.cooldowns", "modulename": "MFramework.commands.cooldowns", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.cooldowns.cooldowns", "modulename": "MFramework.commands.cooldowns", "qualname": "cooldowns", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, Dict[mdiscord.base_model.Snowflake, datetime.datetime]]", "default_value": " = {}"}, {"fullname": "MFramework.commands.cooldowns.Bucket", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "MFramework.commands.cooldowns.Bucket.USER", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket.USER", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Bucket.USER: 'user_id'>"}, {"fullname": "MFramework.commands.cooldowns.Bucket.GUILD", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket.GUILD", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Bucket.GUILD: 'guild_id'>"}, {"fullname": "MFramework.commands.cooldowns.Bucket.CHANNEL", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket.CHANNEL", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Bucket.CHANNEL: 'channel_id'>"}, {"fullname": "MFramework.commands.cooldowns.Bucket.ROLE", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket.ROLE", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Bucket.ROLE: 'roles'>"}, {"fullname": "MFramework.commands.cooldowns.Bucket.GROUP", "modulename": "MFramework.commands.cooldowns", "qualname": "Bucket.GROUP", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.commands._utils.Groups", "default_value": " = <Bucket.GROUP: 'permission_group'>"}, {"fullname": "MFramework.commands.cooldowns.Cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown", "type": "class", "doc": "<p>Base cooldown calculation class</p>\n"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.__init__", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.__init__", "type": "function", "doc": "<p>_cooldown:\n    Delta of a cooldown\n_cooldown_type:\n    Name of this cooldown</p>\n", "signature": "(\n    self,\n    ctx: MFramework.context.Context,\n    cooldown: datetime.timedelta,\n    cooldown_type: str,\n    bucket: MFramework.commands.cooldowns.Bucket = None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.ctx", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.ctx", "type": "variable", "doc": "<p>Command Context for cooldown calculation</p>\n", "annotation": ": MFramework.context.Context"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.cooldown", "type": "variable", "doc": "<p>Cooldown value</p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.now", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.now", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.last_action", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.last_action", "type": "variable", "doc": "<p>Returns time of last execution</p>\n", "annotation": ": datetime.datetime"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.bucket", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.bucket", "type": "variable", "doc": "<p>Returns ID of bucket cooldown should be applied to</p>\n", "annotation": ": mdiscord.base_model.Snowflake"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.add_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.add_cooldown", "type": "function", "doc": "<p>Saves last execution</p>\n", "signature": "(self, value=None) -> None", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.elapsed", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.elapsed", "type": "variable", "doc": "<p>Elapsed since last action</p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.remaining", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.remaining", "type": "variable", "doc": "<p>Remaining cooldown</p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "MFramework.commands.cooldowns.Cooldown.on_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Cooldown.on_cooldown", "type": "variable", "doc": "<p>Whether the cooldown is still active</p>\n", "annotation": ": bool"}, {"fullname": "MFramework.commands.cooldowns.CacheCooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "CacheCooldown", "type": "class", "doc": "<p>Cooldown stored (and manages) in remote cache like Redis</p>\n", "bases": "Cooldown"}, {"fullname": "MFramework.commands.cooldowns.CacheCooldown.last_action", "modulename": "MFramework.commands.cooldowns", "qualname": "CacheCooldown.last_action", "type": "variable", "doc": "<p>Returns time of last execution</p>\n", "annotation": ": datetime.datetime"}, {"fullname": "MFramework.commands.cooldowns.CacheCooldown.add_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "CacheCooldown.add_cooldown", "type": "function", "doc": "<p>Saves last execution</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.DatabaseCooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "DatabaseCooldown", "type": "class", "doc": "<p>Cooldown timestamp stored in a database table</p>\n", "bases": "Cooldown"}, {"fullname": "MFramework.commands.cooldowns.DatabaseCooldown.__init__", "modulename": "MFramework.commands.cooldowns", "qualname": "DatabaseCooldown.__init__", "type": "function", "doc": "<p>_cooldown:\n    Delta of a cooldown\n_cooldown_type:\n    Name of this cooldown</p>\n", "signature": "(\n    self,\n    ctx: MFramework.context.Context,\n    cooldown: datetime.timedelta,\n    cooldown_type: str,\n    table: Any,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.DatabaseCooldown.last_action", "modulename": "MFramework.commands.cooldowns", "qualname": "DatabaseCooldown.last_action", "type": "variable", "doc": "<p>Returns time of last execution</p>\n", "annotation": ": datetime.datetime"}, {"fullname": "MFramework.commands.cooldowns.DatabaseCooldown.add_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "DatabaseCooldown.add_cooldown", "type": "function", "doc": "<p>Saves last execution</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.Tokens", "modulename": "MFramework.commands.cooldowns", "qualname": "Tokens", "type": "class", "doc": "<p>Simple Tokens counter before applying cooldown</p>\n", "bases": "Cooldown"}, {"fullname": "MFramework.commands.cooldowns.Tokens.__init__", "modulename": "MFramework.commands.cooldowns", "qualname": "Tokens.__init__", "type": "function", "doc": "<p>_cooldown:\n    Delta of a cooldown\n_cooldown_type:\n    Name of this cooldown</p>\n", "signature": "(\n    self,\n    ctx: MFramework.context.Context,\n    capacity: int,\n    cooldown: datetime.timedelta,\n    cooldown_type: str,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.Tokens.last_action", "modulename": "MFramework.commands.cooldowns", "qualname": "Tokens.last_action", "type": "variable", "doc": "<p>Returns time of last execution</p>\n", "annotation": ": datetime.datetime"}, {"fullname": "MFramework.commands.cooldowns.Tokens.add_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Tokens.add_cooldown", "type": "function", "doc": "<p>Saves last execution</p>\n", "signature": "(self, value=None) -> None", "funcdef": "def"}, {"fullname": "MFramework.commands.cooldowns.Tokens.on_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "Tokens.on_cooldown", "type": "variable", "doc": "<p>Whether the cooldown is still active</p>\n", "annotation": ": bool"}, {"fullname": "MFramework.commands.cooldowns.SlidingWindow", "modulename": "MFramework.commands.cooldowns", "qualname": "SlidingWindow", "type": "class", "doc": "<p>Remaining Tokens affected by usage during cooldown's previous window</p>\n", "bases": "Tokens"}, {"fullname": "MFramework.commands.cooldowns.SlidingWindow.on_cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "SlidingWindow.on_cooldown", "type": "variable", "doc": "<p>Whether the cooldown is still active</p>\n", "annotation": ": bool"}, {"fullname": "MFramework.commands.cooldowns.cooldown", "modulename": "MFramework.commands.cooldowns", "qualname": "cooldown", "type": "function", "doc": "<p>Applies a cooldown on command.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rate:</strong>: After how many uses cooldown should be applied</li>\n<li><strong>bucket:</strong>: Group which cooldown is applied to (User, Guild, Channel, Role, Group). Default: User</li>\n<li><strong>scope:</strong>: Group of cooldowns (Global, Functions, Function). Default: Function</li>\n<li><strong>logic:</strong>: Backend class which handles Cooldown calculation on command invocation</li>\n<li><strong>delta:</strong>: Delta to be used as a cooldown value</li>\n<li><strong>cooldown_kwargs:</strong>: Keyword arguments that should be passed to Cooldown (logic) class</li>\n<li><strong>Use it with callable function accepting interaction returning boolean for conditional execution and datetime object with last execution timestamp for cooldown calculation</strong></li>\n</ul>\n", "signature": "(\n    rate: int = 1,\n    bucket: MFramework.commands.cooldowns.Bucket = <Bucket.USER: 'user_id'>,\n    scope: str = None,\n    *,\n    seconds: int = 0,\n    minutes: int = 0,\n    hours: int = 0,\n    days: int = 0,\n    weeks: int = 0,\n    logic: MFramework.commands.cooldowns.Cooldown = <class 'MFramework.commands.cooldowns.Cooldown'>,\n    delta: datetime.timedelta = None,\n    **cooldown_kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators", "modulename": "MFramework.commands.decorators", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.decorators.Event", "modulename": "MFramework.commands.decorators", "qualname": "Event", "type": "function", "doc": "<p>Executes command only if it's during provided timeframe</p>\n", "signature": "(\n    *,\n    month: int = None,\n    day: int = None,\n    hour: int = None,\n    minute: int = None,\n    year: int = None\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.EventBetween", "modulename": "MFramework.commands.decorators", "qualname": "EventBetween", "type": "function", "doc": "<p>Executes only if it's between provided timeframes</p>\n\n<p>For year parameters, specify how many years should be added/deduced</p>\n", "signature": "(\n    *,\n    after_month: int = None,\n    after_day: int = None,\n    after_hour: int = None,\n    after_minute: int = None,\n    after_year: int = None,\n    before_month: int = None,\n    before_day: int = None,\n    before_hour: int = None,\n    before_minute: int = None,\n    before_year: int = None\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.Cooldown", "modulename": "MFramework.commands.decorators", "qualname": "Cooldown", "type": "function", "doc": "<p>Applies a cooldown on command.\nUse it with callable function accepting interaction returning boolean for conditional execution and datetime object with last execution timestamp for cooldown calculation</p>\n", "signature": "(\n    *,\n    seconds: int = None,\n    minutes: int = None,\n    hours: int = None,\n    days: int = None,\n    weeks: int = None,\n    logic: Callable = <function <lambda>>\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.Chance", "modulename": "MFramework.commands.decorators", "qualname": "Chance", "type": "function", "doc": "<p>Randomizes execution</p>\n\n<p>Chance can be between 0 and 100</p>\n", "signature": "(chance: float = 0, fail_message: str = None)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.req_regex", "modulename": "MFramework.commands.decorators", "qualname": "req_regex", "type": "function", "doc": "<p>Checks for Regular Expression in Message's content</p>\n", "signature": "(expression: str)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.regex", "modulename": "MFramework.commands.decorators", "qualname": "regex", "type": "function", "doc": "<p>Checks for Regular Expression in Message's content</p>\n", "signature": "(\n    expression: str,\n    group: MFramework.commands._utils.Groups = <Groups.GLOBAL: 100>\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.register", "modulename": "MFramework.commands.decorators", "qualname": "register", "type": "function", "doc": "<p>Decorator for creating commands.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group:</strong>: is a lowest group that can access this command (Highest digit). DM and Muted are special groups</li>\n<li><strong>interaction:</strong>: whether this function should be an interaction or not</li>\n<li><strong>main:</strong>: is a function pointer.</li>\n<li><strong>guild</strong> ():\nis used when command is exclusive to a specific guild</li>\n<li><strong>choice:</strong>: whether this should be triggered depending on choice on main function</li>\n<li><strong>aliases:</strong>: List of possible alias names</li>\n<li><strong>name:</strong>: Overwrites default name inferred from function name</li>\n<li><strong>help:</strong>: Overwrites default help string inferred from function's docstring</li>\n<li><strong>auto_defer:</strong>: Whether automatically respond with deferred state upon receiving command.</li>\n<li><strong>private_response:</strong>: Whether auto response should be set to private</li>\n</ul>\n", "signature": "(\n    group: MFramework.commands._utils.Groups = <Groups.GLOBAL: 100>,\n    interaction: bool = True,\n    main=False,\n    guild: mdiscord.base_model.Snowflake = None,\n    choice: bool = None,\n    aliases: List[str] = [],\n    name: str = None,\n    help: str = None,\n    auto_defer: bool = True,\n    private_response: bool = False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.shortcut", "modulename": "MFramework.commands.decorators", "qualname": "shortcut", "type": "function", "doc": "<p>Creates shortcut that prefils specified keywords with provided values</p>\n", "signature": "(\n    name: str,\n    group: MFramework.commands._utils.Groups = <Groups.GLOBAL: 100>,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.any_role", "modulename": "MFramework.commands.decorators", "qualname": "any_role", "type": "function", "doc": "<p>Checks if user has any provided role.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>required:</strong>: Checks if provided role IDs or role names are present on calling user</li>\n</ul>\n", "signature": "(*required: Union[mdiscord.base_model.Snowflake, str])", "funcdef": "def"}, {"fullname": "MFramework.commands.decorators.reaction", "modulename": "MFramework.commands.decorators", "qualname": "reaction", "type": "function", "doc": "<p>Makes command respond to reaction as a trigger</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reaction:</strong>: Reaction which should trigger this function</li>\n<li><strong>group:</strong>: is a lowest group that can access this command (Highest digit). DM and Muted are special groups</li>\n<li><strong>guild</strong> ():\nis used when command is exclusive to a specific guild</li>\n</ul>\n", "signature": "(\n    reaction: str,\n    group: MFramework.commands._utils.Groups = <Groups.GLOBAL: 100>,\n    guild: mdiscord.base_model.Snowflake = None\n)", "funcdef": "def"}, {"fullname": "MFramework.commands.interactions", "modulename": "MFramework.commands.interactions", "type": "module", "doc": "<h6 id=\"interactions\">Interactions</h6>\n\n<p>Interaction commands registery &amp; execution framework</p>\n\n<p>:copyright: (c) 2021 Mmesek</p>\n"}, {"fullname": "MFramework.commands.interactions.interaction_create", "modulename": "MFramework.commands.interactions", "qualname": "interaction_create", "type": "function", "doc": "<p>Called after receiving event INTERACTION_CREATE from Discord</p>\n", "signature": "(client: MFramework.bot.Bot, interaction: mdiscord.types.Interaction)", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.ready", "modulename": "MFramework.commands.interactions", "qualname": "ready", "type": "function", "doc": "<p>Called after connecting with Discord. Preferably after receiving READY event</p>\n", "signature": "(client: MFramework.bot.Bot, ready: mdiscord.models.Ready)", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.guild_create", "modulename": "MFramework.commands.interactions", "qualname": "guild_create", "type": "function", "doc": "<p>Called after GUILD_CREATE</p>\n", "signature": "(client: MFramework.bot.Bot, guild: mdiscord.types.Guild)", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.register_commands", "modulename": "MFramework.commands.interactions", "qualname": "register_commands", "type": "function", "doc": "<p></p>\n", "signature": "(client: MFramework.bot.Bot, guild: mdiscord.types.Guild = None)", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.set_permissions", "modulename": "MFramework.commands.interactions", "qualname": "set_permissions", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    guild_id: mdiscord.base_model.Snowflake,\n    _commands: List[MFramework.commands._utils.Command]\n) -> None", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.get_commands", "modulename": "MFramework.commands.interactions", "qualname": "get_commands", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    guild: mdiscord.types.Guild = None\n) -> List[mdiscord.models.Application_Command]", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.add_command", "modulename": "MFramework.commands.interactions", "qualname": "add_command", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    cmd: mdiscord.models.Application_Command,\n    guild: mdiscord.types.Guild = None\n) -> mdiscord.models.Application_Command", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.edit_command", "modulename": "MFramework.commands.interactions", "qualname": "edit_command", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    cmd: mdiscord.models.Application_Command,\n    guild: mdiscord.types.Guild = None\n) -> mdiscord.models.Application_Command", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.delete_command", "modulename": "MFramework.commands.interactions", "qualname": "delete_command", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    cmd: mdiscord.models.Application_Command,\n    guild: mdiscord.types.Guild = None\n) -> None", "funcdef": "async def"}, {"fullname": "MFramework.commands.interactions.overwrite_commands", "modulename": "MFramework.commands.interactions", "qualname": "overwrite_commands", "type": "function", "doc": "<p></p>\n", "signature": "(\n    client: MFramework.bot.Bot,\n    commands: List[mdiscord.models.Application_Command] = [],\n    guild: mdiscord.types.Guild = None\n) -> List[mdiscord.models.Application_Command]", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser", "modulename": "MFramework.commands.parser", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.commands.parser.command", "modulename": "MFramework.commands.parser", "qualname": "command", "type": "function", "doc": "<p></p>\n", "signature": "(cls=None)", "funcdef": "def"}, {"fullname": "MFramework.commands.parser.react", "modulename": "MFramework.commands.parser", "qualname": "react", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ctx: MFramework.bot.Bot,\n    data: mdiscord.types.Message,\n    r: List[str],\n    x: int\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser.message", "modulename": "MFramework.commands.parser", "qualname": "message", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ctx: MFramework.bot.Bot,\n    data: mdiscord.types.Message,\n    r: List[str],\n    x: int\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser.reply", "modulename": "MFramework.commands.parser", "qualname": "reply", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ctx: MFramework.bot.Bot,\n    data: mdiscord.types.Message,\n    r: List[str],\n    x: int\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser.delete", "modulename": "MFramework.commands.parser", "qualname": "delete", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ctx: MFramework.bot.Bot,\n    data: mdiscord.types.Message,\n    r: List[str],\n    x: int\n)", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser.chance", "modulename": "MFramework.commands.parser", "qualname": "chance", "type": "function", "doc": "<p></p>\n", "signature": "(\n    ctx: MFramework.bot.Bot,\n    data: mdiscord.types.Message,\n    r: List[str],\n    x: int\n) -> int", "funcdef": "async def"}, {"fullname": "MFramework.commands.parser.parse", "modulename": "MFramework.commands.parser", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "signature": "(ctx: MFramework.bot.Bot, data: mdiscord.types.Message)", "funcdef": "async def"}, {"fullname": "MFramework.context", "modulename": "MFramework.context", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.context.Context", "modulename": "MFramework.context", "qualname": "Context", "type": "class", "doc": "<p>This is meant as an unified context object used for universal \ncommands that can be issued as both a message or an interaction</p>\n", "bases": "mdiscord.types.Sendable"}, {"fullname": "MFramework.context.Context.__init__", "modulename": "MFramework.context", "qualname": "Context.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    cache: MFramework.database.cache.Cache,\n    bot: MFramework.bot.Bot,\n    data: Union[mdiscord.types.Message, mdiscord.types.Interaction]\n)", "funcdef": "def"}, {"fullname": "MFramework.context.Context.cache", "modulename": "MFramework.context", "qualname": "Context.cache", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.settings.Settings, MFramework.database.cache.settings.Roles, MFramework.database.cache.logging.Logging, MFramework.database.cache.guild.ObjectCollections, MFramework.database.cache.base.Commands"}, {"fullname": "MFramework.context.Context.permission_group", "modulename": "MFramework.context", "qualname": "Context.permission_group", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.context.Context.is_dm", "modulename": "MFramework.context", "qualname": "Context.is_dm", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.context.Context.get_dm", "modulename": "MFramework.context", "qualname": "Context.get_dm", "type": "function", "doc": "<p></p>\n", "signature": "(self, user_id: mdiscord.base_model.Snowflake = None)", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.send_dm", "modulename": "MFramework.context", "qualname": "Context.send_dm", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    content: str = None,\n    embeds: List[mdiscord.types.Embed] = None,\n    components: List[mdiscord.models.Component] = None,\n    file: bytes = None,\n    filename: str = None,\n    allowed_mentions: mdiscord.models.Allowed_Mentions = None,\n    message_reference: mdiscord.models.Message_Reference = None,\n    reply: bool = None\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.reply", "modulename": "MFramework.context", "qualname": "Context.reply", "type": "function", "doc": "<p>Creates reply message.\nBasically a wrapper around <code>send</code> method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>content:</strong>: Message to send</li>\n<li><strong>embeds:</strong>: List of embeds to send</li>\n<li><strong>components:</strong>: List of components to send</li>\n<li><strong>file:</strong>: Binary blob to send</li>\n<li><strong>filename:</strong>: Name of file to send</li>\n<li><strong>allowed_mentions:</strong>: Allowed Mentions structure</li>\n<li><strong>message_reference:</strong>: Message_Reference object message is a reply to</li>\n<li><strong>private:</strong>: Whether message should be send as ephemeral response for interaction (or DM for message) or not</li>\n</ul>\n", "signature": "(\n    self,\n    content: str = None,\n    embeds: List[mdiscord.types.Embed] = None,\n    components: List[mdiscord.models.Component] = None,\n    file: bytes = None,\n    filename: str = None,\n    allowed_mentions: mdiscord.models.Allowed_Mentions = None,\n    message_reference: mdiscord.models.Message_Reference = None,\n    private: bool = None\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.send", "modulename": "MFramework.context", "qualname": "Context.send", "type": "function", "doc": "<p>Sends message</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>content:</strong>: Message to send</li>\n<li><strong>embeds:</strong>: List of embeds to send</li>\n<li><strong>components:</strong>: List of components to send</li>\n<li><strong>file:</strong>: Binary blob to send</li>\n<li><strong>filename:</strong>: Name of file to send</li>\n<li><strong>allowed_mentions:</strong>: Allowed Mentions structure</li>\n<li><strong>message_reference:</strong>: Message_Reference object message is a reply to</li>\n<li><strong>reply:</strong>: Whether this message should attach to original message and reply to it</li>\n<li><strong>private:</strong>: Whether message should be send as ephemeral response for interaction (or DM for message) or not</li>\n</ul>\n", "signature": "(\n    self,\n    content: str = None,\n    embeds: List[mdiscord.types.Embed] = None,\n    components: List[mdiscord.models.Component] = None,\n    file: bytes = None,\n    filename: str = None,\n    allowed_mentions: mdiscord.models.Allowed_Mentions = None,\n    message_reference: mdiscord.models.Message_Reference = None,\n    reply: bool = None,\n    private: bool = None,\n    channel_id: mdiscord.base_model.Snowflake = None\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.edit", "modulename": "MFramework.context", "qualname": "Context.edit", "type": "function", "doc": "<p>Edits message</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>content:</strong>: Message to send</li>\n<li><strong>embeds:</strong>: List of embeds to send</li>\n<li><strong>components:</strong>: List of components to send</li>\n<li><strong>attachments:</strong>: List of attachments to keep</li>\n<li><strong>file:</strong>: Binary blob to send</li>\n<li><strong>filename:</strong>: Name of file to send</li>\n<li><strong>flags:</strong>: Flags message should be send with</li>\n<li><strong>allowed_mentions:</strong>: Allowed Mentions structure</li>\n</ul>\n", "signature": "(\n    self,\n    content: str = None,\n    embeds: List[mdiscord.types.Embed] = None,\n    components: List[mdiscord.models.Component] = None,\n    attachments: List[mdiscord.models.Attachment] = None,\n    file: bytes = None,\n    filename: str = None,\n    allowed_mentions: mdiscord.models.Allowed_Mentions = None,\n    flags: mdiscord.models.Message_Flags = None\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.delete", "modulename": "MFramework.context", "qualname": "Context.delete", "type": "function", "doc": "<p>Deletes message</p>\n", "signature": "(\n    self,\n    message_id: mdiscord.base_model.Snowflake = None,\n    reason: str = None\n) -> None", "funcdef": "async def"}, {"fullname": "MFramework.context.Context.deferred", "modulename": "MFramework.context", "qualname": "Context.deferred", "type": "function", "doc": "<p>Shows loading state when executed on Interaction or typing when executed on Message</p>\n", "signature": "(self, private: bool = False) -> None", "funcdef": "async def"}, {"fullname": "MFramework.database", "modulename": "MFramework.database", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy", "modulename": "MFramework.database.alchemy", "type": "module", "doc": "<h6 id=\"database-models\">Database Models</h6>\n\n<p>Models representing various structures in Database</p>\n\n<p>:copyright: (c) 2020-2021 Mmesek</p>\n"}, {"fullname": "MFramework.database.alchemy.mixins", "modulename": "MFramework.database.alchemy.mixins", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.Snowflake", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Snowflake", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.Snowflake.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Snowflake.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.Snowflake.id", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Snowflake.id", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = Column(None, BigInteger(), table=None, primary_key=True, nullable=False)"}, {"fullname": "MFramework.database.alchemy.mixins.Cooldown", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Cooldown", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.Cooldown.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Cooldown.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.Cooldown.cooldown", "modulename": "MFramework.database.alchemy.mixins", "qualname": "Cooldown.cooldown", "type": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": " = Column(None, Interval(), table=None)"}, {"fullname": "MFramework.database.alchemy.mixins.ForeignMixin", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ForeignMixin", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.ForeignMixin.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ForeignMixin.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.TypeID", "modulename": "MFramework.database.alchemy.mixins", "qualname": "TypeID", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.TypeID.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "TypeID.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.TypeID.type_id", "modulename": "MFramework.database.alchemy.mixins", "qualname": "TypeID.type_id", "type": "variable", "doc": "<p>Represents a column in a database table.</p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.mixins.ServerID", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ServerID", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.ServerID.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ServerID.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.ServerID.server_id", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ServerID.server_id", "type": "variable", "doc": "<p>Represents a column in a database table.</p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.mixins.RoleID", "modulename": "MFramework.database.alchemy.mixins", "qualname": "RoleID", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.RoleID.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "RoleID.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.RoleID.role_id", "modulename": "MFramework.database.alchemy.mixins", "qualname": "RoleID.role_id", "type": "variable", "doc": "<p>Represents a column in a database table.</p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.mixins.RoleID.role", "modulename": "MFramework.database.alchemy.mixins", "qualname": "RoleID.role", "type": "variable", "doc": "<p>Describes an object property that holds a single item or list\nof items that correspond to a related database table.</p>\n\n<p>Public constructor is the <code>_orm.relationship</code> function.</p>\n\n<p><em>seealso:</em>\n:ref:<code>relationship_config_toplevel</code></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.ChannelID", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ChannelID", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.mixins.ChannelID.__init__", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ChannelID.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.mixins.ChannelID.channel_id", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ChannelID.channel_id", "type": "variable", "doc": "<p>Represents a column in a database table.</p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.mixins.ChannelID.channel", "modulename": "MFramework.database.alchemy.mixins", "qualname": "ChannelID.channel", "type": "variable", "doc": "<p>Describes an object property that holds a single item or list\nof items that correspond to a related database table.</p>\n\n<p>Public constructor is the <code>_orm.relationship</code> function.</p>\n\n<p><em>seealso:</em>\n:ref:<code>relationship_config_toplevel</code></p>\n"}, {"fullname": "MFramework.database.alchemy.models", "modulename": "MFramework.database.alchemy.models", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Server", "modulename": "MFramework.database.alchemy.models", "qualname": "Server", "type": "class", "doc": "<p>Servers table representing server in Database</p>\n", "bases": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated, MFramework.database.alchemy.mixins.Snowflake, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Server.__init__", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.__init__", "type": "function", "doc": "<p>A simple constructor that allows initialization from kwargs.</p>\n\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n\n<p>Only keys that are present as\nattributes of the instance's class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.models.Server.channels", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.channels", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Channel]"}, {"fullname": "MFramework.database.alchemy.models.Server.roles", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.roles", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Role]"}, {"fullname": "MFramework.database.alchemy.models.Server.webhooks", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.webhooks", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Webhook]"}, {"fullname": "MFramework.database.alchemy.models.Server.settings", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.settings", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Server.id", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.id", "type": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.models.Server.Setting", "modulename": "MFramework.database.alchemy.models", "qualname": "Server.Setting", "type": "class", "doc": "<p>Polymorphic Setting mixin</p>\n\n<h6 id=\"columns\">Columns</h6>\n\n<p>name:\n    <code>Setting</code> type of this setting</p>\n", "bases": "MFramework.database.alchemy.table_mixins.Setting, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Role", "modulename": "MFramework.database.alchemy.models", "qualname": "Role", "type": "class", "doc": "<p>Roles table representing role in Database</p>\n", "bases": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated, MFramework.database.alchemy.mixins.ServerID, MFramework.database.alchemy.mixins.Snowflake, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Role.__init__", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.__init__", "type": "function", "doc": "<p>A simple constructor that allows initialization from kwargs.</p>\n\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n\n<p>Only keys that are present as\nattributes of the instance's class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.models.Role.server", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.server", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.models.Server"}, {"fullname": "MFramework.database.alchemy.models.Role.settings", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.settings", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Role.server_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.server_id", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Role.id", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.id", "type": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.models.Role.Setting", "modulename": "MFramework.database.alchemy.models", "qualname": "Role.Setting", "type": "class", "doc": "<p>Polymorphic Setting mixin</p>\n\n<h6 id=\"columns\">Columns</h6>\n\n<p>name:\n    <code>Setting</code> type of this setting</p>\n", "bases": "MFramework.database.alchemy.table_mixins.Setting, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Channel", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel", "type": "class", "doc": "<p>Channels table representing channel in Database</p>\n", "bases": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated, MFramework.database.alchemy.mixins.ServerID, MFramework.database.alchemy.mixins.Snowflake, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Channel.__init__", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.__init__", "type": "function", "doc": "<p>A simple constructor that allows initialization from kwargs.</p>\n\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n\n<p>Only keys that are present as\nattributes of the instance's class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.models.Channel.server", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.server", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.models.Server"}, {"fullname": "MFramework.database.alchemy.models.Channel.webhooks", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.webhooks", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Webhook]"}, {"fullname": "MFramework.database.alchemy.models.Channel.settings", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.settings", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Channel.server_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.server_id", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Channel.id", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.id", "type": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.models.Channel.Setting", "modulename": "MFramework.database.alchemy.models", "qualname": "Channel.Setting", "type": "class", "doc": "<p>Polymorphic Setting mixin</p>\n\n<h6 id=\"columns\">Columns</h6>\n\n<p>name:\n    <code>Setting</code> type of this setting</p>\n", "bases": "MFramework.database.alchemy.table_mixins.Setting, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Webhook", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook", "type": "class", "doc": "<p>Webhooks related to Channel</p>\n", "bases": "MFramework.database.alchemy.mixins.ChannelID, MFramework.database.alchemy.mixins.ServerID, MFramework.database.alchemy.mixins.Snowflake, sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Webhook.__init__", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.__init__", "type": "function", "doc": "<p>A simple constructor that allows initialization from kwargs.</p>\n\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n\n<p>Only keys that are present as\nattributes of the instance's class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.models.Webhook.token", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.token", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "MFramework.database.alchemy.models.Webhook.subscriptions", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.subscriptions", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Subscription]"}, {"fullname": "MFramework.database.alchemy.models.Webhook.channel_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.channel_id", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Webhook.channel", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.channel", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Webhook.server_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.server_id", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.models.Webhook.id", "modulename": "MFramework.database.alchemy.models", "qualname": "Webhook.id", "type": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "MFramework.database.alchemy.models.Subscription", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription", "type": "class", "doc": "<p>Subscriptions related to Webhooks</p>\n", "bases": "sqlalchemy.orm.decl_api.Base"}, {"fullname": "MFramework.database.alchemy.models.Subscription.__init__", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.__init__", "type": "function", "doc": "<p>A simple constructor that allows initialization from kwargs.</p>\n\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n\n<p>Only keys that are present as\nattributes of the instance's class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.models.Subscription.webhook_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.webhook_id", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.mixins.Snowflake"}, {"fullname": "MFramework.database.alchemy.models.Subscription.webhook", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.webhook", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[MFramework.database.alchemy.models.Webhook]"}, {"fullname": "MFramework.database.alchemy.models.Subscription.thread_id", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.thread_id", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.mixins.Snowflake"}, {"fullname": "MFramework.database.alchemy.models.Subscription.source", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.source", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "MFramework.database.alchemy.models.Subscription.content", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.content", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "MFramework.database.alchemy.models.Subscription.regex", "modulename": "MFramework.database.alchemy.models", "qualname": "Subscription.regex", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "MFramework.database.alchemy.table_mixins", "modulename": "MFramework.database.alchemy.table_mixins", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.table_mixins.ProxiedDictMixin", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "ProxiedDictMixin", "type": "class", "doc": "<p>Adds obj[key] access to a mapped class.</p>\n\n<p>This class basically proxies dictionary access to an attribute\ncalled <code>_proxied</code>.  The class which inherits this class\nshould have an attribute called <code>_proxied</code> which points to a dictionary.</p>\n"}, {"fullname": "MFramework.database.alchemy.table_mixins.ProxiedDictMixin.__init__", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "ProxiedDictMixin.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting", "type": "class", "doc": "<p>Polymorphic Setting mixin</p>\n\n<h6 id=\"columns\">Columns</h6>\n\n<p>name:\n    <code>Setting</code> type of this setting</p>\n"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.__init__", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.name", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.name", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.types.Setting", "default_value": " = Column(None, Enum('Flags', 'Permissions', 'Color', 'Exp', 'Voice_Exp', 'Gender', 'Timezone', 'Birthday', 'Locale', 'Region', 'Currency', 'Alias', 'Dynamic', 'Buffer', 'RPG', 'DM_Inbox', 'Questions', 'Level', 'Reaction', 'Presence', 'Custom', 'Activity', 'Voice_Link', 'Special', 'Group', 'Nitro', 'ServerID', 'ChannelID', 'MessageID', 'RoleID', 'UserID', 'Allowed_Duplicated_Messages', 'Should_Remove_Links', 'Auto_Mute_Infractions', 'Auto_Mute_Duration', 'Auto_Ban_Infractions', 'Limit_Nitro_Roles', 'Stream', name='setting'), table=None, primary_key=True, nullable=False)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.int", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.int", "type": "variable", "doc": "<p></p>\n", "annotation": ": Column(None, Integer(), table=None)", "default_value": " = Column(None, Integer(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.str", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.str", "type": "variable", "doc": "<p></p>\n", "annotation": ": Column(None, String(), table=None)", "default_value": " = Column(None, String(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.bool", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.bool", "type": "variable", "doc": "<p></p>\n", "annotation": ": Column(None, Boolean(), table=None)", "default_value": " = Column(None, Boolean(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.snowflake", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.snowflake", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.alchemy.mixins.Snowflake", "default_value": " = Column(None, BigInteger(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.date", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.date", "type": "variable", "doc": "<p></p>\n", "annotation": ": datetime.date", "default_value": " = Column(None, Date(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.Setting.float", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "Setting.float", "type": "variable", "doc": "<p></p>\n", "annotation": ": Column(None, Float(), table=None)", "default_value": " = Column(None, Float(), table=None)"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.__init__", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.settings", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.settings", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.with_setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.with_setting", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, value)", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.add_setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.add_setting", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    setting: MFramework.database.alchemy.types.Setting,\n    value: Any\n) -> None", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.modify_setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.modify_setting", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    setting: MFramework.database.alchemy.types.Setting,\n    value: Any\n) -> None", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.remove_setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.remove_setting", "type": "function", "doc": "<p></p>\n", "signature": "(self, setting: MFramework.database.alchemy.types.Setting) -> Any", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.table_mixins.HasDictSettingsRelated.get_setting", "modulename": "MFramework.database.alchemy.table_mixins", "qualname": "HasDictSettingsRelated.get_setting", "type": "function", "doc": "<p></p>\n", "signature": "(self, setting: MFramework.database.alchemy.types.Setting) -> Any", "funcdef": "def"}, {"fullname": "MFramework.database.alchemy.types", "modulename": "MFramework.database.alchemy.types", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.alchemy.types.Permissions", "modulename": "MFramework.database.alchemy.types", "qualname": "Permissions", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "builtins.bytes, mlib.types.Enum"}, {"fullname": "MFramework.database.alchemy.types.Permissions.permission", "modulename": "MFramework.database.alchemy.types", "qualname": "Permissions.permission", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.commands._utils.Groups"}, {"fullname": "MFramework.database.alchemy.types.Setting", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "mlib.types.Enum"}, {"fullname": "MFramework.database.alchemy.types.Setting.Flags", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Flags", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Flags: 0>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Permissions", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Permissions", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Permissions: 1>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Color", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Color", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Color: 2>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Exp", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Exp", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = <Setting.Exp: 3>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Voice_Exp", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Voice_Exp", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Voice_Exp: 4>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Gender", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Gender", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.Gender: 5>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Timezone", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Timezone", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Timezone: 10>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Birthday", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Birthday", "type": "variable", "doc": "<p></p>\n", "annotation": ": datetime.date", "default_value": " = <Setting.Birthday: 11>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Locale", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Locale", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Locale: 12>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Region", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Region", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Region: 13>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Currency", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Currency", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = <Setting.Currency: 14>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Alias", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Alias", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Alias: 15>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Dynamic", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Dynamic", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.Dynamic: 21>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Buffer", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Buffer", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.Buffer: 22>"}, {"fullname": "MFramework.database.alchemy.types.Setting.RPG", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.RPG", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.RPG: 23>"}, {"fullname": "MFramework.database.alchemy.types.Setting.DM_Inbox", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.DM_Inbox", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.DM_Inbox: 24>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Questions", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Questions", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.Questions: 25>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Level", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Level", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Level: 31>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Reaction", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Reaction", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Reaction: 32>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Presence", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Presence", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Presence: 33>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Custom", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Custom", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.Custom: 34>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Activity", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Activity", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Activity: 35>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Voice_Link", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Voice_Link", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.Voice_Link: 36>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Special", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Special", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Special: 37>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Group", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Group", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Group: 38>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Nitro", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Nitro", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.Nitro: 39>"}, {"fullname": "MFramework.database.alchemy.types.Setting.ServerID", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.ServerID", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.ServerID: 40>"}, {"fullname": "MFramework.database.alchemy.types.Setting.ChannelID", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.ChannelID", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.ChannelID: 41>"}, {"fullname": "MFramework.database.alchemy.types.Setting.MessageID", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.MessageID", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.MessageID: 42>"}, {"fullname": "MFramework.database.alchemy.types.Setting.RoleID", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.RoleID", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.RoleID: 43>"}, {"fullname": "MFramework.database.alchemy.types.Setting.UserID", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.UserID", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = <Setting.UserID: 44>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Allowed_Duplicated_Messages", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Allowed_Duplicated_Messages", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Allowed_Duplicated_Messages: 50>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Should_Remove_Links", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Should_Remove_Links", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = <Setting.Should_Remove_Links: 51>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Auto_Mute_Infractions", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Auto_Mute_Infractions", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Auto_Mute_Infractions: 52>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Auto_Mute_Duration", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Auto_Mute_Duration", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Auto_Mute_Duration: 53>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Auto_Ban_Infractions", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Auto_Ban_Infractions", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Auto_Ban_Infractions: 54>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Limit_Nitro_Roles", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Limit_Nitro_Roles", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = <Setting.Limit_Nitro_Roles: 55>"}, {"fullname": "MFramework.database.alchemy.types.Setting.Stream", "modulename": "MFramework.database.alchemy.types", "qualname": "Setting.Stream", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = <Setting.Stream: 60>"}, {"fullname": "MFramework.database.alchemy.types.Flags", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.IntFlag"}, {"fullname": "MFramework.database.alchemy.types.Flags.Chat", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags.Chat", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Flags.Chat: 1>"}, {"fullname": "MFramework.database.alchemy.types.Flags.Voice", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags.Voice", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Flags.Voice: 2>"}, {"fullname": "MFramework.database.alchemy.types.Flags.Presence", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags.Presence", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Flags.Presence: 4>"}, {"fullname": "MFramework.database.alchemy.types.Flags.Activity", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags.Activity", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Flags.Activity: 8>"}, {"fullname": "MFramework.database.alchemy.types.Flags.Nitro", "modulename": "MFramework.database.alchemy.types", "qualname": "Flags.Nitro", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Flags.Nitro: 16>"}, {"fullname": "MFramework.database.cache", "modulename": "MFramework.database.cache", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.Cache", "modulename": "MFramework.database.cache", "qualname": "Cache", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.settings.Settings, MFramework.database.cache.settings.Roles, MFramework.database.cache.logging.Logging, MFramework.database.cache.guild.ObjectCollections, MFramework.database.cache.base.Commands"}, {"fullname": "MFramework.database.cache.Cache.__init__", "modulename": "MFramework.database.cache", "qualname": "Cache.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    bot,\n    guild: mdiscord.types.Guild,\n    rds: Optional[MFramework.database.cache_internal.backends.Redis] = None\n)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base", "modulename": "MFramework.database.cache.base", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.base.Base", "modulename": "MFramework.database.cache.base", "qualname": "Base", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.base.Base.__init__", "modulename": "MFramework.database.cache.base", "qualname": "Base.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, bot, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base.Base.setBot", "modulename": "MFramework.database.cache.base", "qualname": "Base.setBot", "type": "function", "doc": "<p></p>\n", "signature": "(self, user_id)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base.Base.setColor", "modulename": "MFramework.database.cache.base", "qualname": "Base.setColor", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base.Base.calculate_permissions", "modulename": "MFramework.database.cache.base", "qualname": "Base.calculate_permissions", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base.Base.cachedRoles", "modulename": "MFramework.database.cache.base", "qualname": "Base.cachedRoles", "type": "function", "doc": "<p></p>\n", "signature": "(self, roles)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.base.Commands", "modulename": "MFramework.database.cache.base", "qualname": "Commands", "type": "class", "doc": "<p></p>\n", "bases": "Base"}, {"fullname": "MFramework.database.cache.base.Commands.alias", "modulename": "MFramework.database.cache.base", "qualname": "Commands.alias", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = '?'"}, {"fullname": "MFramework.database.cache.database", "modulename": "MFramework.database.cache.database", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.database.Database", "modulename": "MFramework.database.cache.database", "qualname": "Database", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.guild.Guild"}, {"fullname": "MFramework.database.cache.database.Database.__init__", "modulename": "MFramework.database.cache.database", "qualname": "Database.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, bot, guild: MFramework.database.cache.guild.Guild, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.database.Database.new_guild", "modulename": "MFramework.database.cache.database", "qualname": "Database.new_guild", "type": "function", "doc": "<p></p>\n", "signature": "(self, s)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.database.Database.get_guild", "modulename": "MFramework.database.cache.database", "qualname": "Database.get_guild", "type": "function", "doc": "<p></p>\n", "signature": "(self, s) -> MFramework.database.alchemy.models.Server", "funcdef": "def"}, {"fullname": "MFramework.database.cache.database.Database.load_from_database", "modulename": "MFramework.database.cache.database", "qualname": "Database.load_from_database", "type": "function", "doc": "<p></p>\n", "signature": "(self, ctx)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.database.Database.save_to_database", "modulename": "MFramework.database.cache.database", "qualname": "Database.save_to_database", "type": "function", "doc": "<p></p>\n", "signature": "(self, s)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild", "modulename": "MFramework.database.cache.guild", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.guild.Guild", "modulename": "MFramework.database.cache.guild", "qualname": "Guild", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.base.Base"}, {"fullname": "MFramework.database.cache.guild.Guild.__init__", "modulename": "MFramework.database.cache.guild", "qualname": "Guild.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, guild: mdiscord.types.Guild, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections", "type": "class", "doc": "<p></p>\n", "bases": "Guild"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.__init__", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    *,\n    bot,\n    guild: MFramework.database.cache.guild.Guild,\n    rds: Optional[MFramework.database.cache_internal.backends.Redis] = None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.messages", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.messages", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.Messages", "default_value": " = <MFramework.database.cache_internal.models.Messages object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.channels", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.channels", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.Channels", "default_value": " = <MFramework.database.cache_internal.models.Channels object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.roles", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.roles", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.Roles", "default_value": " = <MFramework.database.cache_internal.models.Roles object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.emojis", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.emojis", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[mdiscord.base_model.Snowflake, mdiscord.models.Emoji]", "default_value": " = {}"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.members", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.members", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.Members", "default_value": " = <MFramework.database.cache_internal.models.Members object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.presence", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.presence", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.Presences", "default_value": " = <MFramework.database.cache_internal.models.Presences object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.kv", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.kv", "type": "variable", "doc": "<p></p>\n", "annotation": ": MFramework.database.cache_internal.models.KeyValue", "default_value": " = <MFramework.database.cache_internal.models.KeyValue object>"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.load_voice_states", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.load_voice_states", "type": "function", "doc": "<p></p>\n", "signature": "(self, voice_states)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.setRoleGroups", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.setRoleGroups", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.setChannels", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.setChannels", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.guild.ObjectCollections.cachedVoice", "modulename": "MFramework.database.cache.guild", "qualname": "ObjectCollections.cachedVoice", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.listeners", "modulename": "MFramework.database.cache.listeners", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.listeners.guild_create", "modulename": "MFramework.database.cache.listeners", "qualname": "guild_create", "type": "function", "doc": "<p></p>\n", "signature": "(bot: MFramework.bot.Bot, guild: mdiscord.types.Guild)", "funcdef": "async def"}, {"fullname": "MFramework.database.cache.listeners.create_cache_listeners", "modulename": "MFramework.database.cache.listeners", "qualname": "create_cache_listeners", "type": "function", "doc": "<p></p>\n", "signature": "(Cache: object)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.logging", "modulename": "MFramework.database.cache.logging", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.logging.Logging", "modulename": "MFramework.database.cache.logging", "qualname": "Logging", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.database.Database"}, {"fullname": "MFramework.database.cache.logging.Logging.__init__", "modulename": "MFramework.database.cache.logging", "qualname": "Logging.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, bot, guild: mdiscord.types.Guild, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.logging.Logging.webhooks", "modulename": "MFramework.database.cache.logging", "qualname": "Logging.webhooks", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, Tuple[mdiscord.base_model.Snowflake, str]]", "default_value": " = {}"}, {"fullname": "MFramework.database.cache.logging.Logging.get_Webhooks", "modulename": "MFramework.database.cache.logging", "qualname": "Logging.get_Webhooks", "type": "function", "doc": "<p></p>\n", "signature": "(self, session)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.logging.Logging.set_loggers", "modulename": "MFramework.database.cache.logging", "qualname": "Logging.set_loggers", "type": "function", "doc": "<p></p>\n", "signature": "(self, ctx)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings", "modulename": "MFramework.database.cache.settings", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache.settings.Roles", "modulename": "MFramework.database.cache.settings", "qualname": "Roles", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.database.Database"}, {"fullname": "MFramework.database.cache.settings.Roles.__init__", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, bot, guild: mdiscord.types.Guild, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Roles.get_reaction_roles", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.get_reaction_roles", "type": "function", "doc": "<p></p>\n", "signature": "(self, roles)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Roles.get_activity_roles", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.get_activity_roles", "type": "function", "doc": "<p></p>\n", "signature": "(self, roles)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Roles.get_role_groups", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.get_role_groups", "type": "function", "doc": "<p></p>\n", "signature": "(self, roles)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Roles.get_level_roles", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.get_level_roles", "type": "function", "doc": "<p></p>\n", "signature": "(self, roles)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Roles.get_Roles", "modulename": "MFramework.database.cache.settings", "qualname": "Roles.get_Roles", "type": "function", "doc": "<p></p>\n", "signature": "(self, session)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings", "modulename": "MFramework.database.cache.settings", "qualname": "Settings", "type": "class", "doc": "<p></p>\n", "bases": "MFramework.database.cache.database.Database, MFramework.database.cache.guild.ObjectCollections"}, {"fullname": "MFramework.database.cache.settings.Settings.__init__", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *, bot, guild: mdiscord.types.Guild, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings.voice_link", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.voice_link", "type": "variable", "doc": "<p></p>\n", "annotation": ": mdiscord.base_model.Snowflake", "default_value": " = None"}, {"fullname": "MFramework.database.cache.settings.Settings.flags", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.flags", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "MFramework.database.cache.settings.Settings.permissions", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.permissions", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "MFramework.database.cache.settings.Settings.language", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.language", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'en'"}, {"fullname": "MFramework.database.cache.settings.Settings.allowed_duplicated_messages", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.allowed_duplicated_messages", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 1"}, {"fullname": "MFramework.database.cache.settings.Settings.load_settings", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.load_settings", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings.get_rpg_channels", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.get_rpg_channels", "type": "function", "doc": "<p></p>\n", "signature": "(self, channels)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings.get_exp_settings", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.get_exp_settings", "type": "function", "doc": "<p></p>\n", "signature": "(self, channels)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings.get_Channels", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.get_Channels", "type": "function", "doc": "<p></p>\n", "signature": "(self, session)", "funcdef": "def"}, {"fullname": "MFramework.database.cache.settings.Settings.is_tracking", "modulename": "MFramework.database.cache.settings", "qualname": "Settings.is_tracking", "type": "function", "doc": "<p></p>\n", "signature": "(self, flag)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal", "modulename": "MFramework.database.cache_internal", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache_internal.backends", "modulename": "MFramework.database.cache_internal.backends", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary", "type": "class", "doc": "<p>dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)</p>\n", "bases": "typing.Dict"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.__init__", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.add", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.add", "type": "function", "doc": "<p>Add new item to a cache</p>\n", "signature": "(\n    self,\n    name: str,\n    value: str,\n    expire_time: datetime.timedelta = None\n) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.get", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.get", "type": "function", "doc": "<p>Get item from a cache</p>\n", "signature": "(self, name: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.update", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.update", "type": "function", "doc": "<p>Update current value in cache, return old value</p>\n", "signature": "(self, name: str, new_value: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.delete", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.delete", "type": "function", "doc": "<p>Delete item from cache</p>\n", "signature": "(self, name: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.save", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.save", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.shutdown", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.shutdown", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.db_size", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.db_size", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.has", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.has", "type": "function", "doc": "<p></p>\n", "signature": "(self, name) -> bool", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.exists", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.exists", "type": "function", "doc": "<p></p>\n", "signature": "(self, name) -> bool", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.count", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.count", "type": "function", "doc": "<p></p>\n", "signature": "(self, name) -> int", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Dictionary.keys", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Dictionary.keys", "type": "function", "doc": "<p>D.keys() -> a set-like object providing a view on D's keys</p>\n", "signature": "(self, pattern=None) -> List[Any]", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis", "type": "class", "doc": "<p>Implementation of the Redis protocol.</p>\n\n<p>This abstract class provides a Python interface to all Redis commands\nand an implementation of the Redis protocol.</p>\n\n<p>Connection and Pipeline derive from this, implementing how\nthe commands are sent and received to the Redis server</p>\n", "bases": "redis.client.Redis"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.add", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.add", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    value: str,\n    expire_time: datetime.timedelta = None\n) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.get", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.get", "type": "function", "doc": "<p>Return the value at key <code>name</code>, or None if the key doesn't exist</p>\n", "signature": "(self, name: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.update", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.update", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, new_value: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.db_size", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.db_size", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.has", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.has", "type": "function", "doc": "<p></p>\n", "signature": "(self, name)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.backends.Redis.count", "modulename": "MFramework.database.cache_internal.backends", "qualname": "Redis.count", "type": "function", "doc": "<p></p>\n", "signature": "(self, name)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models", "modulename": "MFramework.database.cache_internal.models", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.cache_internal.models.Collection", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n"}, {"fullname": "MFramework.database.cache_internal.models.Collection.__init__", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    cache: Union[MFramework.database.cache_internal.backends.Dictionary, MFramework.database.cache_internal.backends.Redis] = None\n)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.items", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.items", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.keys", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.keys", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.values", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.values", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.update", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.update", "type": "function", "doc": "<p>Update current object(s) in cache</p>\n", "signature": "(self, obj: mdiscord.base_model.DiscordObject)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.pop", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.pop", "type": "function", "doc": "<p></p>\n", "signature": "(self, *args, default=None)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.get", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.get", "type": "function", "doc": "<p></p>\n", "signature": "(self, id: mdiscord.base_model.Snowflake, default=None)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.from_list", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.from_list", "type": "function", "doc": "<p>Fill cache from list</p>\n", "signature": "(\n    self,\n    iterable: List[mdiscord.base_model.DiscordObject],\n    guild_id=None\n) -> None", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.store", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.store", "type": "function", "doc": "<p>Store a single item</p>\n", "signature": "(self, obj: mdiscord.base_model.DiscordObject)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.has", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.has", "type": "function", "doc": "<p>Check if provided key exisits in cache</p>\n", "signature": "(self, name: str) -> bool", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Collection.delete", "modulename": "MFramework.database.cache_internal.models", "qualname": "Collection.delete", "type": "function", "doc": "<p>Delete from Cache</p>\n", "signature": "(self, obj_id: mdiscord.base_model.DiscordObject)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Messages", "modulename": "MFramework.database.cache_internal.models", "qualname": "Messages", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Messages.has", "modulename": "MFramework.database.cache_internal.models", "qualname": "Messages.has", "type": "function", "doc": "<p>Check if provided key exisits in cache</p>\n", "signature": "(self, guild_id, channel_id, message_id)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Messages.last", "modulename": "MFramework.database.cache_internal.models", "qualname": "Messages.last", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild_id, channel_id)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Messages.size", "modulename": "MFramework.database.cache_internal.models", "qualname": "Messages.size", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild_id, channel_id)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Channels", "modulename": "MFramework.database.cache_internal.models", "qualname": "Channels", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Roles", "modulename": "MFramework.database.cache_internal.models", "qualname": "Roles", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Users", "modulename": "MFramework.database.cache_internal.models", "qualname": "Users", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Members", "modulename": "MFramework.database.cache_internal.models", "qualname": "Members", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Members.size", "modulename": "MFramework.database.cache_internal.models", "qualname": "Members.size", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild_id)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Presences", "modulename": "MFramework.database.cache_internal.models", "qualname": "Presences", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Presences.store", "modulename": "MFramework.database.cache_internal.models", "qualname": "Presences.store", "type": "function", "doc": "<p>Store a single item</p>\n", "signature": "(self, data: mdiscord.models.Presence_Update)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Guilds", "modulename": "MFramework.database.cache_internal.models", "qualname": "Guilds", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Cooldowns", "modulename": "MFramework.database.cache_internal.models", "qualname": "Cooldowns", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.Cooldowns.get", "modulename": "MFramework.database.cache_internal.models", "qualname": "Cooldowns.get", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    guild_id: mdiscord.base_model.Snowflake,\n    user_id: mdiscord.base_model.Snowflake,\n    type: str\n)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Cooldowns.has", "modulename": "MFramework.database.cache_internal.models", "qualname": "Cooldowns.has", "type": "function", "doc": "<p>Check if provided key exisits in cache</p>\n", "signature": "(self, guild_id, user_id, type)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Cooldowns.store", "modulename": "MFramework.database.cache_internal.models", "qualname": "Cooldowns.store", "type": "function", "doc": "<p>Store a single item</p>\n", "signature": "(self, guild_id, user_id, type, expire=datetime.timedelta(seconds=60))", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.Context", "modulename": "MFramework.database.cache_internal.models", "qualname": "Context", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.KeyValue", "modulename": "MFramework.database.cache_internal.models", "qualname": "KeyValue", "type": "class", "doc": "<p>Base Collection. </p>\n\n<p>Default ID is composed from Class name and <code>.id</code> attribute of cached object</p>\n", "bases": "Collection"}, {"fullname": "MFramework.database.cache_internal.models.KeyValue.__init__", "modulename": "MFramework.database.cache_internal.models", "qualname": "KeyValue.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    guild_id: int = 0,\n    cache: Union[MFramework.database.cache_internal.backends.Dictionary, MFramework.database.cache_internal.backends.Redis] = None\n)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.KeyValue.store", "modulename": "MFramework.database.cache_internal.models", "qualname": "KeyValue.store", "type": "function", "doc": "<p>Store a single item</p>\n", "signature": "(self, key: str, value: str, expire_time: datetime.timedelta = None)", "funcdef": "def"}, {"fullname": "MFramework.database.cache_internal.models.KeyValue.get", "modulename": "MFramework.database.cache_internal.models", "qualname": "KeyValue.get", "type": "function", "doc": "<p></p>\n", "signature": "(self, key: str)", "funcdef": "def"}, {"fullname": "MFramework.database.database", "modulename": "MFramework.database.database", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Influx", "modulename": "MFramework.database.database", "qualname": "Influx", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Influx.__init__", "modulename": "MFramework.database.database", "qualname": "Influx.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, cfg: dict)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.influx", "modulename": "MFramework.database.database", "qualname": "Influx.influx", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Influx.write_api", "modulename": "MFramework.database.database", "qualname": "Influx.write_api", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Influx.query_api", "modulename": "MFramework.database.database", "qualname": "Influx.query_api", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Influx.point", "modulename": "MFramework.database.database", "qualname": "Influx.point", "type": "function", "doc": "<p></p>\n", "signature": "(self, measurement_name)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.influxMember", "modulename": "MFramework.database.database", "qualname": "Influx.influxMember", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    serverID,\n    userID,\n    joined_or_left,\n    timestamp=datetime.datetime(2022, 3, 22, 0, 51, 40, 580818)\n)", "funcdef": "async def"}, {"fullname": "MFramework.database.database.Influx.influxMembers", "modulename": "MFramework.database.database", "qualname": "Influx.influxMembers", "type": "function", "doc": "<p>Users = [(UserID, timestamp)]</p>\n", "signature": "(self, serverID, users: tuple)", "funcdef": "async def"}, {"fullname": "MFramework.database.database.Influx.getMembersChange", "modulename": "MFramework.database.database", "qualname": "Influx.getMembersChange", "type": "function", "doc": "<p></p>\n", "signature": "(self, server_id, period: str, state: str = 'joined')", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.influxGetMember", "modulename": "MFramework.database.database", "qualname": "Influx.influxGetMember", "type": "function", "doc": "<p></p>\n", "signature": "(self, server)", "funcdef": "async def"}, {"fullname": "MFramework.database.database.Influx.commitVoiceSession", "modulename": "MFramework.database.database", "qualname": "Influx.commitVoiceSession", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    server,\n    channel,\n    user,\n    delta,\n    timestamp='2022-03-22T00:51:40.580818'\n)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.commitPresence", "modulename": "MFramework.database.database", "qualname": "Influx.commitPresence", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    server,\n    user,\n    game,\n    delta,\n    timestamp='2022-03-22T00:51:40.580818'\n)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.commitMessage", "modulename": "MFramework.database.database", "qualname": "Influx.commitMessage", "type": "function", "doc": "<p></p>\n", "signature": "(self, server, channel, user, words)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.commitCommandUsage", "modulename": "MFramework.database.database", "qualname": "Influx.commitCommandUsage", "type": "function", "doc": "<p></p>\n", "signature": "(self, server_id, command_name, bot_name, success=True, user_id=0)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.getSession", "modulename": "MFramework.database.database", "qualname": "Influx.getSession", "type": "function", "doc": "<p></p>\n", "signature": "(self, user, interval)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.getMessages", "modulename": "MFramework.database.database", "qualname": "Influx.getMessages", "type": "function", "doc": "<p></p>\n", "signature": "(self, user)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.get", "modulename": "MFramework.database.database", "qualname": "Influx.get", "type": "function", "doc": "<p></p>\n", "signature": "(self, query)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.get_server", "modulename": "MFramework.database.database", "qualname": "Influx.get_server", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    limit,\n    interval,\n    guild_id,\n    measurement,\n    fn='count',\n    additional=''\n)", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.get_command_usage", "modulename": "MFramework.database.database", "qualname": "Influx.get_command_usage", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild_id, interval='30d')", "funcdef": "def"}, {"fullname": "MFramework.database.database.Influx.influxPing", "modulename": "MFramework.database.database", "qualname": "Influx.influxPing", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "async def"}, {"fullname": "MFramework.database.database.Supabase", "modulename": "MFramework.database.database", "qualname": "Supabase", "type": "class", "doc": "<p></p>\n", "bases": "mlib.database.Supabase"}, {"fullname": "MFramework.database.database.Supabase.increase_exp", "modulename": "MFramework.database.database", "qualname": "Supabase.increase_exp", "type": "function", "doc": "<p></p>\n", "signature": "(self, server_id: int, user_id: int, value: float = 1) -> float", "funcdef": "async def"}, {"fullname": "MFramework.database.database.Database", "modulename": "MFramework.database.database", "qualname": "Database", "type": "class", "doc": "<p></p>\n"}, {"fullname": "MFramework.database.database.Database.__init__", "modulename": "MFramework.database.database", "qualname": "Database.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, config: dict)", "funcdef": "def"}, {"fullname": "MFramework.utils", "modulename": "MFramework.utils", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.utils.leaderboards", "modulename": "MFramework.utils.leaderboards", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard_Entry", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard_Entry", "type": "class", "doc": "<p>Helper class representing user and a corresponding value</p>\n"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard_Entry.__init__", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard_Entry.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    ctx: MFramework.context.Context,\n    user_id: mdiscord.base_model.Snowflake,\n    value: int,\n    value_processing: Callable = <function Leaderboard_Entry.<lambda>>\n)", "funcdef": "def"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard_Entry.value", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard_Entry.value", "type": "variable", "doc": "<p>Processed value of entry</p>\n", "annotation": ": int"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard_Entry.name", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard_Entry.name", "type": "variable", "doc": "<p>Username corresponding to this user ID</p>\n", "annotation": ": str"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard_Entry.in_guild", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard_Entry.in_guild", "type": "variable", "doc": "<p>Checks if user is still in guild's cache</p>\n", "annotation": ": bool"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard", "type": "class", "doc": "<p>Leaderboard builder sorting and formatting leaderboard</p>\n"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.__init__", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    ctx: MFramework.context.Context,\n    user_id: mdiscord.base_model.Snowflake,\n    iterable: List[MFramework.utils.leaderboards.Leaderboard_Entry],\n    limit: int = 10,\n    error: str = 'No results',\n    skip_invalid: bool = False\n)", "funcdef": "def"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.postion_str", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.postion_str", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = '{position}. {value}'"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.marked_str", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.marked_str", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = '__{}__'"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.leaderboard", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.leaderboard", "type": "variable", "doc": "<p>Sorted List of strings</p>\n", "annotation": ": List"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.user_stats", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.user_stats", "type": "variable", "doc": "<p>User leaderboard statistic</p>\n", "annotation": ": int"}, {"fullname": "MFramework.utils.leaderboards.Leaderboard.as_embed", "modulename": "MFramework.utils.leaderboards", "qualname": "Leaderboard.as_embed", "type": "function", "doc": "<p>Returns embed with leaderboard &amp; optionally user stats</p>\n", "signature": "(\n    self,\n    title: str = 'Leaderboard',\n    add_user: bool = True,\n    user_title: str = None,\n    user_inline: bool = False\n) -> mdiscord.types.Embed", "funcdef": "def"}, {"fullname": "MFramework.utils.log", "modulename": "MFramework.utils.log", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.utils.log.Log", "modulename": "MFramework.utils.log", "qualname": "Log", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n"}, {"fullname": "MFramework.utils.log.Log.__init__", "modulename": "MFramework.utils.log", "qualname": "Log.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    bot: MFramework.bot.Bot,\n    guild_id: mdiscord.base_model.Snowflake,\n    type: str,\n    id: mdiscord.base_model.Snowflake,\n    token: str\n)", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Log.username", "modulename": "MFramework.utils.log", "qualname": "Log.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Basic Logger'"}, {"fullname": "MFramework.utils.log.Log.avatar", "modulename": "MFramework.utils.log", "qualname": "Log.avatar", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = None"}, {"fullname": "MFramework.utils.log.Log.localized", "modulename": "MFramework.utils.log", "qualname": "Log.localized", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Log.log", "modulename": "MFramework.utils.log", "qualname": "Log.log", "type": "function", "doc": "<p></p>\n", "signature": "(self, event: Any) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Log.log_dm", "modulename": "MFramework.utils.log", "qualname": "Log.log_dm", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event: Any,\n    user_id: mdiscord.base_model.Snowflake\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Message", "modulename": "MFramework.utils.log", "qualname": "Message", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Log"}, {"fullname": "MFramework.utils.log.Message.username", "modulename": "MFramework.utils.log", "qualname": "Message.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Message Log'"}, {"fullname": "MFramework.utils.log.Message.set_metadata", "modulename": "MFramework.utils.log", "qualname": "Message.set_metadata", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg: mdiscord.types.Message) -> mdiscord.types.Embed", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Message.user_in_footer", "modulename": "MFramework.utils.log", "qualname": "Message.user_in_footer", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    embed: mdiscord.types.Embed,\n    msg: mdiscord.types.Message\n) -> mdiscord.types.Embed", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Message.get_cached_message", "modulename": "MFramework.utils.log", "qualname": "Message.get_cached_message", "type": "function", "doc": "<p></p>\n", "signature": "(self, key: mdiscord.base_model.Snowflake) -> mdiscord.types.Message", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Message.cached_message", "modulename": "MFramework.utils.log", "qualname": "Message.cached_message", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg: mdiscord.types.Message) -> mdiscord.types.Embed", "funcdef": "def"}, {"fullname": "MFramework.utils.log.Message_Update", "modulename": "MFramework.utils.log", "qualname": "Message_Update", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Message"}, {"fullname": "MFramework.utils.log.Message_Update.log", "modulename": "MFramework.utils.log", "qualname": "Message_Update.log", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg: mdiscord.types.Message) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Message_Delete", "modulename": "MFramework.utils.log", "qualname": "Message_Delete", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Message"}, {"fullname": "MFramework.utils.log.Message_Delete.log", "modulename": "MFramework.utils.log", "qualname": "Message_Delete.log", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg: mdiscord.types.Message) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.User", "modulename": "MFramework.utils.log", "qualname": "User", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Log"}, {"fullname": "MFramework.utils.log.User.log", "modulename": "MFramework.utils.log", "qualname": "User.log", "type": "function", "doc": "<p></p>\n", "signature": "(self, event: mdiscord.models.Guild_Member) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Guild_Member_Add", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Add", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "User"}, {"fullname": "MFramework.utils.log.Guild_Member_Add.username", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Add.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Joined Log'"}, {"fullname": "MFramework.utils.log.Guild_Member_Add.log", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Add.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Guild_Member_Add\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Guild_Member_Remove", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Remove", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "User"}, {"fullname": "MFramework.utils.log.Guild_Member_Remove.username", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Remove.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Leave Log'"}, {"fullname": "MFramework.utils.log.Guild_Member_Remove.log", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Remove.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Guild_Member_Remove\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Voice", "modulename": "MFramework.utils.log", "qualname": "Voice", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Log"}, {"fullname": "MFramework.utils.log.Voice.username", "modulename": "MFramework.utils.log", "qualname": "Voice.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Voice Log'"}, {"fullname": "MFramework.utils.log.Voice.log", "modulename": "MFramework.utils.log", "qualname": "Voice.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Voice_State,\n    channel: mdiscord.base_model.Snowflake = '',\n    after: int = None\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Guild_Member_Update", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Update", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Log"}, {"fullname": "MFramework.utils.log.Guild_Member_Update.username", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Update.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Member Update Log'"}, {"fullname": "MFramework.utils.log.Guild_Member_Update.log", "modulename": "MFramework.utils.log", "qualname": "Guild_Member_Update.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Guild_Member_Update\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Nitro_Change", "modulename": "MFramework.utils.log", "qualname": "Nitro_Change", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Guild_Member_Update"}, {"fullname": "MFramework.utils.log.Nitro_Change.username", "modulename": "MFramework.utils.log", "qualname": "Nitro_Change.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Nitro Log'"}, {"fullname": "MFramework.utils.log.Nitro_Change.log", "modulename": "MFramework.utils.log", "qualname": "Nitro_Change.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Guild_Member_Update\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.log.Muted_Change", "modulename": "MFramework.utils.log", "qualname": "Muted_Change", "type": "class", "doc": "<p>Base Log class. Subclass it and overwrite <code>.log()</code> and optionally <code>.log_dm()</code> to create new log. \nIf it's about one of Discord Dispatch events, the name should match (For example: <code>Message_Delete</code> for logging deleted messages)</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>username:</strong>: Name webhook when using this logger</li>\n<li><strong>avatar:</strong>: URL to avatar to use when using this logger</li>\n</ul>\n", "bases": "Guild_Member_Update"}, {"fullname": "MFramework.utils.log.Muted_Change.username", "modulename": "MFramework.utils.log", "qualname": "Muted_Change.username", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Muted Log'"}, {"fullname": "MFramework.utils.log.Muted_Change.log", "modulename": "MFramework.utils.log", "qualname": "Muted_Change.log", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data: mdiscord.models.Guild_Member_Update\n) -> mdiscord.types.Message", "funcdef": "async def"}, {"fullname": "MFramework.utils.utils", "modulename": "MFramework.utils.utils", "type": "module", "doc": "<p></p>\n"}, {"fullname": "MFramework.utils.utils.parseMention", "modulename": "MFramework.utils.utils", "qualname": "parseMention", "type": "function", "doc": "<p></p>\n", "signature": "(message: str) -> str", "funcdef": "def"}, {"fullname": "MFramework.utils.utils.param", "modulename": "MFramework.utils.utils", "qualname": "param", "type": "function", "doc": "<p></p>\n", "signature": "(message: str) -> list", "funcdef": "def"}, {"fullname": "MFramework.utils.utils.get_usernames", "modulename": "MFramework.utils.utils", "qualname": "get_usernames", "type": "function", "doc": "<p></p>\n", "signature": "(self, guild_id: int, user_id: int) -> str", "funcdef": "async def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();